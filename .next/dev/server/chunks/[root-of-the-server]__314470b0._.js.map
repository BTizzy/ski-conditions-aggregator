{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/ryanbartell/ski-conditions-aggregator/app/api/radar/lib/interpolation.ts"],"sourcesContent":["// IDW (Inverse Distance Weighting) interpolation for gridded radar tiles\n// See COPILOT_PROMPT.md for methodology and requirements\n\nexport interface Point {\n  lat: number;\n  lon: number;\n  value: number;\n}\n\nexport interface Grid {\n  width: number;\n  height: number;\n  lat0: number; // NW corner\n  lon0: number; // NW corner\n  lat1: number; // SE corner\n  lon1: number; // SE corner\n  data: number[][]; // [y][x] grid of interpolated values\n}\n\nexport interface IDWOptions {\n  power?: number; // IDW power parameter (default 2)\n  radius?: number; // Max distance in km to consider (optional)\n  minPoints?: number; // Minimum points to interpolate (default 1)\n  nodata?: number; // Value to use if no points in radius (default NaN)\n}\n\n// Haversine distance in km\nfunction haversine(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371;\n  const dLat = (lat2 - lat1) * Math.PI / 180;\n  const dLon = (lon2 - lon1) * Math.PI / 180;\n  const a = Math.sin(dLat/2) ** 2 + Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) * Math.sin(dLon/2) ** 2;\n  return 2 * R * Math.asin(Math.sqrt(a));\n}\n\n// IDW interpolation for a grid\nexport function idwGrid(\n  points: Point[],\n  width: number,\n  height: number,\n  lat0: number,\n  lon0: number,\n  lat1: number,\n  lon1: number,\n  options: IDWOptions = {}\n): Grid {\n  const power = options.power ?? 2;\n  const radius = options.radius ?? Infinity;\n  const minPoints = options.minPoints ?? 1;\n  const nodata = options.nodata ?? NaN;\n  const data: number[][] = [];\n  for (let y = 0; y < height; y++) {\n    const row: number[] = [];\n    const lat = lat0 + (lat1 - lat0) * (y / (height - 1));\n    for (let x = 0; x < width; x++) {\n      const lon = lon0 + (lon1 - lon0) * (x / (width - 1));\n      // Compute weights\n      let sumWeights = 0;\n      let sumValues = 0;\n      let used = 0;\n      for (const pt of points) {\n        const d = haversine(lat, lon, pt.lat, pt.lon);\n        if (d === 0) {\n          row.push(pt.value);\n          used = -1;\n          break;\n        }\n        if (d <= radius) {\n          const w = 1 / Math.pow(d, power);\n          sumWeights += w;\n          sumValues += w * pt.value;\n          used++;\n        }\n      }\n      if (used === -1) continue;\n      if (used >= minPoints && sumWeights > 0) {\n        row.push(sumValues / sumWeights);\n      } else {\n        row.push(nodata);\n      }\n    }\n    data.push(row);\n  }\n  return { width, height, lat0, lon0, lat1, lon1, data };\n}\n"],"names":[],"mappings":"AAAA,yEAAyE;AACzE,yDAAyD;;;;;AAyBzD,2BAA2B;AAC3B,SAAS,UAAU,IAAY,EAAE,IAAY,EAAE,IAAY,EAAE,IAAY;IACvE,MAAM,IAAI;IACV,MAAM,OAAO,CAAC,OAAO,IAAI,IAAI,KAAK,EAAE,GAAG;IACvC,MAAM,OAAO,CAAC,OAAO,IAAI,IAAI,KAAK,EAAE,GAAG;IACvC,MAAM,IAAI,KAAK,GAAG,CAAC,OAAK,MAAM,IAAI,KAAK,GAAG,CAAC,OAAO,KAAK,EAAE,GAAC,OAAO,KAAK,GAAG,CAAC,OAAO,KAAK,EAAE,GAAC,OAAO,KAAK,GAAG,CAAC,OAAK,MAAM;IACpH,OAAO,IAAI,IAAI,KAAK,IAAI,CAAC,KAAK,IAAI,CAAC;AACrC;AAGO,SAAS,QACd,MAAe,EACf,KAAa,EACb,MAAc,EACd,IAAY,EACZ,IAAY,EACZ,IAAY,EACZ,IAAY,EACZ,UAAsB,CAAC,CAAC;IAExB,MAAM,QAAQ,QAAQ,KAAK,IAAI;IAC/B,MAAM,SAAS,QAAQ,MAAM,IAAI;IACjC,MAAM,YAAY,QAAQ,SAAS,IAAI;IACvC,MAAM,SAAS,QAAQ,MAAM,IAAI;IACjC,MAAM,OAAmB,EAAE;IAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC/B,MAAM,MAAgB,EAAE;QACxB,MAAM,MAAM,OAAO,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACpD,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;YAC9B,MAAM,MAAM,OAAO,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACnD,kBAAkB;YAClB,IAAI,aAAa;YACjB,IAAI,YAAY;YAChB,IAAI,OAAO;YACX,KAAK,MAAM,MAAM,OAAQ;gBACvB,MAAM,IAAI,UAAU,KAAK,KAAK,GAAG,GAAG,EAAE,GAAG,GAAG;gBAC5C,IAAI,MAAM,GAAG;oBACX,IAAI,IAAI,CAAC,GAAG,KAAK;oBACjB,OAAO,CAAC;oBACR;gBACF;gBACA,IAAI,KAAK,QAAQ;oBACf,MAAM,IAAI,IAAI,KAAK,GAAG,CAAC,GAAG;oBAC1B,cAAc;oBACd,aAAa,IAAI,GAAG,KAAK;oBACzB;gBACF;YACF;YACA,IAAI,SAAS,CAAC,GAAG;YACjB,IAAI,QAAQ,aAAa,aAAa,GAAG;gBACvC,IAAI,IAAI,CAAC,YAAY;YACvB,OAAO;gBACL,IAAI,IAAI,CAAC;YACX;QACF;QACA,KAAK,IAAI,CAAC;IACZ;IACA,OAAO;QAAE;QAAO;QAAQ;QAAM;QAAM;QAAM;QAAM;IAAK;AACvD"}},
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"sources":["file:///Users/ryanbartell/ski-conditions-aggregator/app/api/radar/tile/route.ts"],"sourcesContent":["import { NextResponse, NextRequest } from 'next/server';\nimport { idwGrid, Point } from '../lib/interpolation';\nimport { getAllResortAreaHistorical, getAccumulatedSnowfallAtLocation, getAccumulatedRainfallAtLocation } from '../lib/historical';\nimport { resorts } from '../../../../lib/resorts';\nimport { PNG } from 'pngjs';\n\nexport const dynamic = 'force-dynamic';\n\n/**\n * Radar Tile Proxy - Returns synthetic radar tile images based on real weather data\n * \n * Data Source: IDW interpolation of historical weather station data\n * Coverage: Northeast US snowfall patterns\n * \n * Query Params:\n *   layer - Must be \"synthetic-{timestamp}\"\n *   z, x, y - Tile coordinates\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = request.nextUrl;\n    \n    const layer = searchParams.get('layer');\n    const z = searchParams.get('z');\n    const x = searchParams.get('x');\n    const y = searchParams.get('y');\n    \n    if (!z || !x || !y || !layer) {\n      return NextResponse.json(\n        { error: 'Missing parameters. Required: layer, z, x, y' },\n        { status: 400 }\n      );\n    }\n    \n    const zNum = parseInt(z);\n    const xNum = parseInt(x);\n    const yNum = parseInt(y);\n    \n    if (isNaN(zNum) || isNaN(xNum) || isNaN(yNum)) {\n      return NextResponse.json({ error: 'Invalid tile coordinates' }, { status: 400 });\n    }\n\n    if (zNum < 0 || zNum > 18) return getTransparentTile();\n    \n    const maxTile = Math.pow(2, zNum);\n    if (xNum < 0 || xNum >= maxTile || yNum < 0 || yNum >= maxTile) {\n      return getTransparentTile();\n    }\n\n    // Handle synthetic data (based on real weather station data)\n    if (layer.startsWith('synthetic-')) {\n      // Synthetic: layer is \"synthetic-{timestamp}\"\n      const timestamp = parseInt(layer.split('-')[1]);\n      if (isNaN(timestamp)) {\n        return NextResponse.json({ error: 'Invalid synthetic timestamp' }, { status: 400 });\n      }\n\n      console.log(`[Tile] Synthetic: z=${zNum} x=${xNum} y=${yNum} time=${timestamp}`);\n      \n      // For performance, use completely synthetic data without API calls for tiles\n      // This avoids rate limiting while still providing realistic radar patterns\n      return await generatePurelySyntheticTile(zNum, xNum, yNum, timestamp);\n    }\n\n    // If we get here, it's an invalid layer format\n    return NextResponse.json({ error: 'Invalid layer format - only synthetic layers supported' }, { status: 400 });\n\n  } catch (error: any) {\n    console.error('[Tile] Error:', error.message);\n    return getTransparentTile();\n  }\n}\n\n// Generate baseline synthetic weather patterns for any tile\nfunction generateBaselineWeatherPatterns(\n  syntheticPoints: Point[], \n  lat0: number, \n  lon0: number, \n  lat1: number, \n  lon1: number, \n  timestamp: number\n): void {\n  // Use timestamp as seed for deterministic but time-varying patterns\n  const seed = timestamp;\n  const seededRandom = (seed: number) => {\n    const x = Math.sin(seed) * 10000;\n    return x - Math.floor(x);\n  };\n\n  // Generate weather systems (storm centers) that move and evolve over time\n  // Create more complex, realistic weather patterns similar to weather.com radar\n  const numSystems = 12; // More systems for complex weather patterns\n  const baseSeed = timestamp;\n  \n  // Add some large-scale weather fronts/patterns\n  const largeScalePatterns = 3; // Fewer but larger weather systems\n  for (let i = 0; i < largeScalePatterns; i++) {\n    // Large weather systems that move slower and cover larger areas\n    const timeOffset = (timestamp / (60 * 60 * 1000)) * 0.2; // Slower movement for large systems\n    const baseLat = lat0 + seededRandom(baseSeed + i * 100) * (lat1 - lat0);\n    const baseLon = lon0 + seededRandom(baseSeed + i * 200) * (lon1 - lon0);\n\n    // Slower, more persistent movement\n    const lat = baseLat + Math.sin(timeOffset + i) * 0.8 + (seededRandom(baseSeed + i * 300) - 0.5) * 0.4;\n    const lon = baseLon + Math.cos(timeOffset + i * 1.2) * 0.8 + (seededRandom(baseSeed + i * 400) - 0.5) * 0.4;\n\n    // More persistent intensity with gradual changes\n    const timeOfDay = (timestamp % (24 * 60 * 60 * 1000)) / (24 * 60 * 60 * 1000);\n    const systemAge = seededRandom(baseSeed + i * 500);\n    const persistence = Math.sin(timeOfDay * Math.PI * 2 + i * 0.5) * 0.3 + 0.7; // 0.4-1.0 persistence\n    const intensity = Math.max(0.01, \n      0.08 + 0.8 * Math.sin(timeOfDay * Math.PI * 2 + i) * \n      Math.sin(systemAge * Math.PI) * seededRandom(baseSeed + i * 600) * persistence\n    );\n    const precipitation = Math.max(0.03, intensity * 3.0); // 0.03-2.4 inches total precip\n\n    // Large systems have more points and wider spread\n    const numPointsPerSystem = 8 + Math.floor(seededRandom(baseSeed + i * 700) * 6); // 8-13 points per system\n    for (let p = 0; p < numPointsPerSystem; p++) {\n      const spreadFactor = 1.5; // Wider spread for large systems\n      const offsetLat = (seededRandom(baseSeed + i * 800 + p * 100) - 0.5) * spreadFactor;\n      const offsetLon = (seededRandom(baseSeed + i * 900 + p * 200) - 0.5) * spreadFactor;\n      const pointIntensity = precipitation * (0.2 + seededRandom(baseSeed + i * 1000 + p * 300) * 0.8);\n\n      syntheticPoints.push({\n        lat: lat + offsetLat,\n        lon: lon + offsetLon,\n        value: pointIntensity\n      });\n    }\n  }\n  \n  // Add smaller, faster-moving weather systems\n  for (let i = largeScalePatterns; i < numSystems; i++) {\n    // Smaller, more dynamic weather systems\n    const timeOffset = (timestamp / (60 * 60 * 1000)) * 0.4; // Faster movement\n    const baseLat = lat0 + seededRandom(baseSeed + i * 100) * (lat1 - lat0);\n    const baseLon = lon0 + seededRandom(baseSeed + i * 200) * (lon1 - lon0);\n\n    // More erratic movement\n    const lat = baseLat + Math.sin(timeOffset + i) * 1.5 + (seededRandom(baseSeed + i * 300) - 0.5) * 0.8;\n    const lon = baseLon + Math.cos(timeOffset + i * 1.4) * 1.5 + (seededRandom(baseSeed + i * 400) - 0.5) * 0.8;\n\n    // More variable intensity\n    const timeOfDay = (timestamp % (24 * 60 * 60 * 1000)) / (24 * 60 * 60 * 1000);\n    const systemAge = seededRandom(baseSeed + i * 500);\n    const intensity = Math.max(0.005, \n      0.03 + 0.5 * Math.sin(timeOfDay * Math.PI * 2 + i * 1.2) * \n      Math.sin(systemAge * Math.PI) * seededRandom(baseSeed + i * 600)\n    );\n    const precipitation = Math.max(0.01, intensity * 1.8); // 0.01-0.9 inches total precip\n\n    // Fewer points for smaller systems\n    const numPointsPerSystem = 4 + Math.floor(seededRandom(baseSeed + i * 700) * 3); // 4-6 points per system\n    for (let p = 0; p < numPointsPerSystem; p++) {\n      const offsetLat = (seededRandom(baseSeed + i * 800 + p * 100) - 0.5) * 0.6;\n      const offsetLon = (seededRandom(baseSeed + i * 900 + p * 200) - 0.5) * 0.6;\n      const pointIntensity = precipitation * (0.3 + seededRandom(baseSeed + i * 1000 + p * 300) * 0.7);\n\n      syntheticPoints.push({\n        lat: lat + offsetLat,\n        lon: lon + offsetLon,\n        value: pointIntensity\n      });\n    }\n  }\n}\n\n// Convert tile coordinates to lat/lon bounds (EPSG:4326)\nfunction getTileBoundsLatLon(z: number, x: number, y: number): string {\n  // Correct Web Mercator to lat/lon conversion\n  const n = Math.pow(2, z);\n  const lon0 = (x / n) * 360 - 180;\n  const lon1 = ((x + 1) / n) * 360 - 180;\n\n  // Correct latitude calculation\n  const lat0 = (2 * Math.atan(Math.exp(Math.PI * (1 - 2 * y / n))) - Math.PI / 2) * 180 / Math.PI;\n  const lat1 = (2 * Math.atan(Math.exp(Math.PI * (1 - 2 * (y + 1) / n))) - Math.PI / 2) * 180 / Math.PI;\n\n  // WMS 1.3.0 BBOX format for EPSG:4326: minY,minX,maxY,maxX\n  // Y is latitude (minY = southern lat, maxY = northern lat)\n  // X is longitude (minX = western lon, maxX = eastern lon)\n  const minLat = Math.min(lat0, lat1);\n  const maxLat = Math.max(lat0, lat1);\n  const minLon = Math.min(lon0, lon1);\n  const maxLon = Math.max(lon0, lon1);\n  return `${minLat},${minLon},${maxLat},${maxLon}`;\n}\n\nfunction getTransparentTile(): Response {\n  // 1x1 transparent PNG\n  const transparentPng = Buffer.from([\n    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,\n    0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,\n    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,\n    0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x15, 0xc4,\n    0x89, 0x00, 0x00, 0x00, 0x0a, 0x49, 0x44, 0x41,\n    0x54, 0x78, 0x9c, 0x63, 0x00, 0x01, 0x00, 0x00,\n    0x05, 0x00, 0x01, 0x0d, 0x0a, 0x2d, 0xb4, 0x00,\n    0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae,\n    0x42, 0x60, 0x82,\n  ]);\n  \n  return new NextResponse(transparentPng, {\n    headers: {\n      'Content-Type': 'image/png',\n      'Cache-Control': 'public, max-age=300',\n      'Access-Control-Allow-Origin': '*'\n    }\n  });\n}\n\nasync function generatePurelySyntheticTile(z: number, x: number, y: number, timestamp: number): Promise<Response> {\n  try {\n    // Get tile bounds\n    const n = Math.pow(2, z);\n    const lon0 = (x / n) * 360 - 180;\n    const lat0 = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;\n    const lon1 = ((x + 1) / n) * 360 - 180;\n    const lat1 = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI;\n\n    // Create synthetic weather patterns without API calls\n    const syntheticPoints: Point[] = [];\n    generateBaselineWeatherPatterns(syntheticPoints, lat0, lon0, lat1, lon1, timestamp);\n\n    console.log(`[Tile] Pure synthetic z=${z} x=${x} y=${y} t=${new Date(timestamp).toISOString().slice(0,16)}: ${syntheticPoints.length} synthetic points`);\n\n    // Use optimized interpolation parameters for realistic weather radar appearance\n    const grid = idwGrid(syntheticPoints, 256, 256, lat0, lon0, lat1, lon1, {\n      power: 2,    // Moderate power for natural falloff\n      radius: 150  // Larger radius for smoother blending between weather systems\n    });\n\n    // Create PNG with Doppler-style radar coloring\n    const pngBuffer = createDopplerRadarPNG(grid.data);\n\n    return new NextResponse(new Uint8Array(pngBuffer), {\n      headers: {\n        'Content-Type': 'image/png',\n        'Cache-Control': 'public, max-age=300',\n        'Access-Control-Allow-Origin': '*'\n      }\n    });\n  } catch (error: any) {\n    console.error('[Tile] Error generating purely synthetic tile:', error.message);\n    return getTransparentTile();\n  }\n}\n\nfunction createDopplerRadarPNG(data: number[][]): Buffer {\n  const width = data[0].length;\n  const height = data.length;\n  const png = new PNG({ width, height });\n\n  // Apply simple smoothing to reduce extreme local variations\n  const smoothedData = smoothGrid(data, 2); // 2-pixel smoothing radius for smoother radar appearance\n\n  // Find max value for scaling (cap at reasonable snowfall amounts)\n  let maxVal = 0;\n  for (const row of smoothedData) {\n    for (const val of row) {\n      if (val > maxVal) maxVal = val;\n    }\n  }\n\n  // Doppler radar color scale (similar to weather.com/Apple Maps)\n  // Based on reflectivity levels, but adapted for snowfall intensity\n  function getDopplerColor(intensity: number): [number, number, number, number] {\n    // Scale 0-1 where 1 is maximum snowfall\n    const normalized = Math.min(intensity, 1);\n\n    if (normalized < 0.1) return [0, 0, 0, 0]; // Transparent for very light/no snow\n    if (normalized < 0.2) return [173, 216, 230, 180]; // Light blue\n    if (normalized < 0.3) return [135, 206, 235, 200]; // Sky blue\n    if (normalized < 0.4) return [70, 130, 180, 220]; // Steel blue\n    if (normalized < 0.5) return [25, 25, 112, 240]; // Midnight blue\n    if (normalized < 0.6) return [0, 100, 0, 255]; // Dark green\n    if (normalized < 0.7) return [34, 139, 34, 255]; // Forest green\n    if (normalized < 0.8) return [255, 215, 0, 255]; // Gold\n    if (normalized < 0.9) return [255, 140, 0, 255]; // Dark orange\n    if (normalized < 0.98) return [220, 20, 60, 255]; // Crimson (less bright red)\n    return [139, 0, 0, 255]; // Dark red for absolute maximum\n  }\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const val = smoothedData[y][x];\n      const intensity = maxVal > 0 ? Math.min(val / Math.max(maxVal, 0.1), 1.0) : 0; // Clamp to [0,1]\n      const [r, g, b, a] = getDopplerColor(intensity);\n\n      const idx = (width * y + x) << 2;\n      png.data[idx] = r;     // R\n      png.data[idx + 1] = g; // G\n      png.data[idx + 2] = b; // B\n      png.data[idx + 3] = a; // A\n    }\n  }\n\n  return PNG.sync.write(png);\n}\n\n// Simple box filter smoothing to reduce extreme local variations\nfunction smoothGrid(data: number[][], radius: number): number[][] {\n  const height = data.length;\n  const width = data[0].length;\n  const smoothed: number[][] = [];\n\n  for (let y = 0; y < height; y++) {\n    const row: number[] = [];\n    for (let x = 0; x < width; x++) {\n      let sum = 0;\n      let count = 0;\n\n      // Average over a box around this pixel\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dx = -radius; dx <= radius; dx++) {\n          const ny = y + dy;\n          const nx = x + dx;\n          if (ny >= 0 && ny < height && nx >= 0 && nx < width && !isNaN(data[ny][nx])) {\n            sum += data[ny][nx];\n            count++;\n          }\n        }\n      }\n\n      row.push(count > 0 ? sum / count : 0);\n    }\n    smoothed.push(row);\n  }\n\n  return smoothed;\n}\n"],"names":[],"mappings":"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"}}]
}